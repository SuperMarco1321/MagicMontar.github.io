<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montador Magic Rampage - By Marco</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #111; color: #fff; padding: 20px; text-align: center; margin: 0; }
        h1 { color: #ffcc00; margin: 10px 0; }
        h2 { color: #ddd; margin: 25px 0 10px; }
        .catalog { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 12px; max-width: 1200px; margin: 0 auto; }
        .item { background: #1a1a1a; padding: 8px; border-radius: 6px; cursor: pointer; transition: all 0.2s; text-align: center; }
        .item:hover { background: #2a2a2a; transform: scale(1.03); }
        .item img { width: 100%; height: 110px; object-fit: contain; image-rendering: pixelated; background: #000; border-radius: 4px; }
        .item span { display: block; margin-top: 6px; font-size: 0.78em; color: #ccc; }
        .item.selected { border: 2px solid #ffcc00; background: #222; }
        canvas { border: 2px solid #444; margin: 25px auto; display: block; image-rendering: pixelated; max-width: 90%; background: #000; border-radius: 6px; }
        button { padding: 12px 28px; background: #ffcc00; color: #000; border: none; font-size: 16px; cursor: pointer; margin: 8px; border-radius: 6px; font-weight: bold; }
        button:hover { background: #ffe044; }
        button:disabled { background: #555; color: #888; cursor: not-allowed; }
        #helmetToggle { min-width: 140px; }
        label { margin: 8px 0; font-size: 1.1em; }
        input[type="color"] { width: 60px; height: 35px; vertical-align: middle; }
        #status { margin: 15px 0; font-size: 1.15em; color: #aaa; }
    </style>
</head>
<body>
    <h1>Montador de Personagens Magic Rampage</h1>
    <p>Criado por Marco para a comunidade</p>

    <label>Cor do corpo: <input type="color" id="bodyColor" value="#ffffff"></label>
    <label>Cor dos olhos: <input type="color" id="eyeColor" value="#ffffff"></label>

    <h2>Corpo (obrigatório)</h2>
    <div class="catalog" id="bodyCatalog"></div>

    <h2>Armadura</h2>
    <button id="helmetToggle">Com Elmo</button>
    <div class="catalog" id="armorCatalog"></div>

    <h2>Amuleto</h2>
    <div class="catalog" id="amuletoCatalog"></div>

    <h2>Pet</h2>
    <div class="catalog" id="petCatalog"></div>

    <h2>Cabeça</h2>
    <div class="catalog" id="headCatalog"></div>

    <h2>Olhos</h2>
    <div class="catalog" id="eyeCatalog"></div>

    <h2>Arma</h2>
    <div class="catalog" id="weaponCatalog"></div>

    <button onclick="updatePreview()">Atualizar Preview</button>
    <button onclick="generateAll()">Gerar ZIP Completo</button>

    <canvas id="preview" width="400" height="400"></canvas>
    <p id="status">Carregando catálogo...</p>

    <script>
        const basePath = '';
        const folders = {
            body: 'Corpo', armor: 'Armaduras', amuleto: 'Amuleto',
            pet: 'Pet', head: 'Cabeça', eye: 'Olho', weapon: 'Arma'
        };

        let catalogData = {};
        let selectedItems = {};
        let loadedAssets = {};
        let bodyTint = {r:255,g:255,b:255};
        let eyeTint = {r:255,g:255,b:255};
        let useHelmet = true;

        const toggleBtn = document.getElementById('helmetToggle');
        toggleBtn.onclick = () => {
            if (toggleBtn.disabled) return;
            useHelmet = !useHelmet;
            toggleBtn.textContent = useHelmet ? 'Com Elmo' : 'Sem Elmo';
            if (selectedItems.armor) loadArmor(selectedItems.armor);
        };

        function createCatalog(id, items, baseFolder, isWeapon = false) {
            const container = document.getElementById(id);
            container.innerHTML = '';
            items.forEach(name => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'item';
                itemDiv.onclick = () => selectItem(id.replace('Catalog',''), name, baseFolder, isWeapon);
                const img = document.createElement('img');
                img.src = `${basePath}${baseFolder}/Png/${name}.png`;
                img.onerror = () => img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAErgG8vK8AAAAASUVORK5CYII='; // 1x1 preto
                const label = document.createElement('span');
                label.textContent = name.replace(/_/g,' ').replace(/[-+]/g,'');
                itemDiv.append(img, label);
                container.appendChild(itemDiv);
            });
        }

        async function selectItem(type, name, folder, isWeapon) {
            document.querySelectorAll(`#${type}Catalog .selected`)?.forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            selectedItems[type] = name;
            if (type === 'armor') {
                await loadArmor(name);
            } else {
                await loadAsset(type, name, folder, isWeapon);
            }
        }

        async function loadArmor(armorName) {
            toggleBtn.disabled = true;
            toggleBtn.textContent = 'Carregando...';
            let variant = useHelmet ? 'a' : 'b';
            let pngPath = `${folders.armor}/Png/${armorName}/armor_${variant}.png`;
            let xmlPath = `${folders.armor}/Xml/${armorName}/armor_${variant}.xml`;

            // Fallback: tenta o primeiro .png que existir (sem API)
            let response = await fetch(basePath + pngPath);
            if (!response.ok) {
                // Tenta o outro variant
                variant = useHelmet ? 'b' : 'a';
                pngPath = `${folders.armor}/Png/${armorName}/armor_${variant}.png`;
                xmlPath = `${folders.armor}/Xml/${armorName}/armor_${variant}.xml`;
                response = await fetch(basePath + pngPath);
                if (!response.ok) {
                    // Último fallback: tenta qualquer .png na pasta (mas precisa do nome exato)
                    document.getElementById('status').textContent = 'Armadura não encontrada ou sem variante';
                    toggleBtn.textContent = useHelmet ? 'Com Elmo' : 'Sem Elmo';
                    return;
                }
            }

            toggleBtn.disabled = false;
            toggleBtn.textContent = useHelmet ? 'Com Elmo' : 'Sem Elmo';

            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = basePath + pngPath;
            await new Promise(r => { img.onload = r; img.onerror = r; });

            loadedAssets.armor = { img, sprites: [] };

            try {
                const xml = await fetch(basePath + xmlPath).then(r => r.ok ? r.text() : '');
                if (xml) loadedAssets.armor.sprites = parseXML(xml);
            } catch {}

            updatePreview();
        }

        async function loadAsset(type, name, folder, isWeapon) {
            const png = `${folder}/Png/${name}.png`;
            const xml = isWeapon ? null : `${folder}/Xml/${name}.xml`;

            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = basePath + png;
            await new Promise(r => { img.onload = r; img.onerror = r; });

            loadedAssets[type] = { img, sprites: [] };

            if (xml) {
                try {
                    const text = await fetch(basePath + xml).then(r => r.text());
                    loadedAssets[type].sprites = parseXML(text);
                } catch {}
            }

            if (isWeapon) {
                try {
                    const ang = await fetch(basePath + 'Arma/Angulos.txt').then(r => r.text());
                    const block = ang.match(new RegExp(`sprite\\s*=\\s*${name.replace('.', '\\.')}[^}]*`, 'i'));
                    if (block) {
                        loadedAssets[type].angle = parseFloat(block[0].match(/equippedAngle\s*=\s*([-.\d]+)/)?.[1] || 0);
                        loadedAssets[type].offset = [
                            parseInt(block[0].match(/equipOffsetX\s*=\s*([-.\d]+)/)?.[1] || 0),
                            parseInt(block[0].match(/equipOffsetY\s*=\s*([-.\d]+)/)?.[1] || 0)
                        ];
                    }
                } catch {}
            }

            updatePreview();
        }

        function parseXML(xmlText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlText, "text/xml");
            const sprites = Array.from(doc.querySelectorAll('sprite')).map(s => ({
                name: s.getAttribute('n'),
                x: parseInt(s.getAttribute('x')),
                y: parseInt(s.getAttribute('y')),
                w: parseInt(s.getAttribute('w')),
                h: parseInt(s.getAttribute('h')),
                oX: parseInt(s.getAttribute('oX') || 0),
                oY: parseInt(s.getAttribute('oY') || 0),
                oW: parseInt(s.getAttribute('oW') || 0),
                oH: parseInt(s.getAttribute('oH') || 0),
                pX: parseFloat(s.getAttribute('pX') || 0.5),
                pY: parseFloat(s.getAttribute('pY') || 0.5)
            }));
            return sprites.sort((a,b) => a.name.localeCompare(b.name));
        }

        function tint(img, color) {
            const c = document.createElement('canvas');
            c.width = img.width; c.height = img.height;
            const ctx = c.getContext('2d');
            ctx.drawImage(img, 0, 0);
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
            ctx.fillRect(0,0,c.width,c.height);
            ctx.globalCompositeOperation = 'destination-atop';
            ctx.drawImage(img, 0, 0);
            return c;
        }

        function getPos(pivotX, pivotY, s) {
            if (!s) return [0,0];
            return [
                pivotX - (s.pX * s.oW - s.oX),
                pivotY - (s.pY * s.oH - s.oY)
            ];
        }

        function crop(img, x,y,w,h) {
            const c = document.createElement('canvas');
            c.width = w; c.height = h;
            c.getContext('2d').drawImage(img, x,y,w,h, 0,0,w,h);
            return c;
        }

        function rotate(img, deg) {
            const rad = deg * Math.PI / 180;
            const s = Math.abs(Math.sin(rad)), c = Math.abs(Math.cos(rad));
            const canvas = document.createElement('canvas');
            canvas.width = img.width * c + img.height * s;
            canvas.height = img.width * s + img.height * c;
            const ctx = canvas.getContext('2d');
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(rad);
            ctx.drawImage(img, -img.width/2, -img.height/2);
            return canvas;
        }

        function montarFrame(idx = 0) {
            if (!loadedAssets.body?.sprites?.length) return null;

            const bodyS = loadedAssets.body.sprites[idx] || loadedAssets.body.sprites[0];
            const pivot = [bodyS.pX * bodyS.oW, bodyS.pY * bodyS.oH];

            let bodyImg = loadedAssets.body.img;
            if (bodyTint.r !== 255 || bodyTint.g !== 255 || bodyTint.b !== 255) {
                bodyImg = tint(bodyImg, bodyTint);
            }

            const crops = [];
            crops.push({
                img: crop(bodyImg, bodyS.x, bodyS.y, bodyS.w, bodyS.h),
                pos: getPos(...pivot, bodyS),
                key: 'body'
            });

            ['armor','amuleto','pet','head'].forEach(k => {
                const layer = loadedAssets[k];
                if (layer?.sprites?.length) {
                    const s = layer.sprites[Math.min(idx, layer.sprites.length-1)] || layer.sprites[0];
                    crops.push({
                        img: crop(layer.img, s.x,s.y,s.w,s.h),
                        pos: getPos(...pivot, s),
                        key: k
                    });
                }
            });

            if (loadedAssets.eye?.sprites?.length) {
                const s = loadedAssets.eye.sprites[Math.min(idx, loadedAssets.eye.sprites.length-1)] || loadedAssets.eye.sprites[0];
                let eyeImg = crop(loadedAssets.eye.img, s.x,s.y,s.w,s.h);
                if (eyeTint.r !== 255 || eyeTint.g !== 255 || eyeTint.b !== 255) {
                    eyeImg = tint(eyeImg, eyeTint);
                }
                crops.push({ img: eyeImg, pos: getPos(...pivot, s), key: 'eye' });
            }

            if (loadedAssets.weapon) {
                const wImg = rotate(loadedAssets.weapon.img, loadedAssets.weapon.angle || 0);
                const off = loadedAssets.weapon.offset || [0,0];
                crops.push({
                    img: wImg,
                    pos: [pivot[0] + off[0] - wImg.width/2, pivot[1] + off[1] - wImg.height/2],
                    key: 'weapon'
                });
            }

            let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
            crops.forEach(c => {
                minX = Math.min(minX, c.pos[0]);
                minY = Math.min(minY, c.pos[1]);
                maxX = Math.max(maxX, c.pos[0] + c.img.width);
                maxY = Math.max(maxY, c.pos[1] + c.img.height);
            });

            const canvas = document.createElement('canvas');
            canvas.width = Math.max(1, Math.ceil(maxX - minX));
            canvas.height = Math.max(1, Math.ceil(maxY - minY));
            const ctx = canvas.getContext('2d');

            ['weapon','body','armor','amuleto','pet','head'].forEach(k => {
                const c = crops.find(cc => cc.key === k);
                if (c) ctx.drawImage(c.img, c.pos[0] - minX, c.pos[1] - minY);
            });

            const eyeLayer = crops.find(c => c.key === 'eye');
            if (eyeLayer) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.drawImage(eyeLayer.img, eyeLayer.pos[0] - minX, eyeLayer.pos[1] - minY);
                ctx.globalCompositeOperation = 'source-over';
            }

            return canvas;
        }

        async function updatePreview() {
            bodyTint = hexToRgb(document.getElementById('bodyColor').value);
            eyeTint = hexToRgb(document.getElementById('eyeColor').value);
            const cv = montarFrame(0);
            if (cv) {
                const prev = document.getElementById('preview');
                prev.width = cv.width;
                prev.height = cv.height;
                prev.getContext('2d').drawImage(cv, 0, 0);
                document.getElementById('status').textContent = 'Preview ok';
            } else {
                document.getElementById('status').textContent = 'Selecione corpo + armadura válida';
            }
        }

        async function generateAll() {
            if (!loadedAssets.body?.sprites?.length) {
                document.getElementById('status').textContent = 'Selecione um corpo primeiro';
                return;
            }
            const zip = new JSZip();
            const total = loadedAssets.body.sprites.length;
            for (let i = 0; i < total; i++) {
                const cv = montarFrame(i);
                if (cv) {
                    const blob = await new Promise(r => cv.toBlob(r, 'image/png'));
                    zip.file(loadedAssets.body.sprites[i].name.replace(/[^a-z0-9]/gi,'_') + '.png', blob);
                }
            }
            const blob = await zip.generateAsync({type:'blob'});
            saveAs(blob, 'MagicRampage_Character.zip');
            document.getElementById('status').textContent = 'ZIP baixado!';
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r:255,g:255,b:255};
        }

        window.onload = async () => {
            try {
                const res = await fetch('catalog.json');
                catalogData = await res.json();

                createCatalog('bodyCatalog', catalogData.body || [], folders.body);
                createCatalog('amuletoCatalog', catalogData.amuleto || [], folders.amuleto);
                createCatalog('petCatalog', catalogData.pet || [], folders.pet);
                createCatalog('headCatalog', catalogData.head || [], folders.head);
                createCatalog('eyeCatalog', catalogData.eye || [], folders.eye);
                createCatalog('weaponCatalog', catalogData.weapon || [], folders.weapon, true);

                // Armaduras especiais
                const armorItems = [];
                (catalogData.armor?.folders || []).forEach(n => armorItems.push(n));
                (catalogData.armor?.single || []).forEach(n => armorItems.push(n));
                createCatalog('armorCatalog', armorItems, folders.armor);

                document.getElementById('status').textContent = 'Catálogo pronto. Selecione um corpo.';
            } catch (err) {
                document.getElementById('status').textContent = 'Erro ao carregar catálogo';
                console.error(err);
            }
        };
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montador Magic Rampage - By Marco</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #111; color: #fff; padding: 20px; text-align: center; }
        h1 { color: #ffcc00; }
        h2 { color: #ddd; margin-top: 30px; }
        .catalog { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; margin: 20px auto; max-width: 1200px; }
        .item { background: #222; padding: 10px; border-radius: 8px; cursor: pointer; transition: 0.3s; }
        .item:hover { background: #333; }
        .item img { width: 100%; height: 100px; object-fit: contain; image-rendering: pixelated; background: rgba(0,0,0,0.5); border-radius: 5px; }
        .item span { display: block; margin-top: 5px; font-size: 0.8em; text-transform: capitalize; }
        .item.selected { border: 3px solid #ffcc00; }
        canvas { border: 2px solid #444; margin: 20px auto; display: block; image-rendering: pixelated; max-width: 100%; background: #000; }
        button { padding: 15px 30px; background: #ffcc00; color: #000; border: none; font-size: 18px; cursor: pointer; margin: 10px; border-radius: 8px; }
        button:hover { background: #ffdd44; }
        label { display: block; margin: 10px 0; }
        input[type="color"] { width: 50px; height: 30px; }
        #status { margin: 20px; font-size: 1.2em; color: #bbb; }
        #helmetToggle { padding: 10px 20px; background: #ffcc00; color: #000; font-size: 16px; margin: 10px auto; display: inline-block; border-radius: 8px; cursor: pointer; }
        #helmetToggle.disabled { background: #555; color: #888; cursor: not-allowed; }
    </style>
</head>
<body>
    <h1>Montador de Personagens Magic Rampage</h1>
    <p>Criado por Marco para a comunidade! Clique nas imagens para selecionar.</p>

    <label>Cor do corpo: <input type="color" id="bodyColor" value="#ffffff"></label>
    <label>Cor dos olhos: <input type="color" id="eyeColor" value="#ffffff"></label>

    <h2>Corpo (obrigatório)</h2>
    <div class="catalog" id="bodyCatalog"></div>

    <h2>Armadura</h2>
    <button id="helmetToggle">Com Elmo</button>
    <div class="catalog" id="armorCatalog"></div>

    <h2>Amuleto</h2>
    <div class="catalog" id="amuletoCatalog"></div>

    <h2>Pet</h2>
    <div class="catalog" id="petCatalog"></div>

    <h2>Cabeça</h2>
    <div class="catalog" id="headCatalog"></div>

    <h2>Olhos (com brilho additive)</h2>
    <div class="catalog" id="eyeCatalog"></div>

    <h2>Arma</h2>
    <div class="catalog" id="weaponCatalog"></div>

    <button onclick="updatePreview()">Atualizar Preview</button>
    <button onclick="generateAll()">Gerar ZIP Completo</button>

    <canvas id="preview" width="400" height="400"></canvas>
    <p id="status">Carregando catálogo...</p>

    <script>
        const basePath = '';
        const folders = {
            body: 'Corpo',
            armor: 'Armaduras',
            amuleto: 'Amuleto',
            pet: 'Pet',
            head: 'Cabeça',
            eye: 'Olho',
            weapon: 'Arma'
        };

        let catalog = {};
        let selected = {};
        let data = {};
        let bodyColor = {r: 255, g: 255, b: 255};
        let eyeColor = {r: 255, g: 255, b: 255};
        let withHelmet = true;
        let folderPreviews = {}; // cache dos primeiros PNG de cada pasta

        const helmetToggle = document.getElementById('helmetToggle');
        helmetToggle.onclick = () => {
            if (helmetToggle.classList.contains('disabled')) return;
            withHelmet = !withHelmet;
            helmetToggle.textContent = withHelmet ? 'Com Elmo' : 'Sem Elmo';
            if (selected.armor) loadArmor(selected.armor.name, selected.armor.type);
        };

        function createCatalog(catId, list, folder, isWeapon = false) {
            const cat = document.getElementById(catId);
            cat.innerHTML = '';
            list.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'item';
                div.onclick = () => {
                    document.querySelectorAll(`#${catId} .selected`).forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                    if (catId === 'armorCatalog') {
                        selected.armor = entry;
                        loadArmor(entry.name, entry.type);
                    } else {
                        selected[catId.replace('Catalog', '')] = entry.name;
                        loadAsset(catId.replace('Catalog', ''), entry.name, folder, isWeapon);
                    }
                };
                const img = document.createElement('img');
                if (catId === 'armorCatalog' && entry.type === 'folder') {
                    // Usa cache ou placeholder enquanto carrega
                    img.src = folderPreviews[entry.name] || 'https://placehold.co/100x100?text=Carregando...';
                    // Carrega preview se ainda não tiver
                    if (!folderPreviews[entry.name]) {
                        loadFolderPreview(entry.name, img);
                    }
                } else {
                    img.src = basePath + `${folder}/Png/${entry.name}.png`;
                }
                img.onerror = () => img.src = 'https://placehold.co/100x100?text=Erro';
                div.appendChild(img);
                const span = document.createElement('span');
                span.innerText = (entry.display || entry.name).replace(/_/g, ' ');
                div.appendChild(span);
                cat.appendChild(div);
            });
        }

        async function loadFolderPreview(folderName, imgElement) {
            const repo = 'SuperMarco1321/MagicMontar.github.io';
            const apiUrl = `https://api.github.com/repos/${repo}/contents/${folders.armor}/Png/${folderName}`;
            try {
                const res = await fetch(apiUrl);
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                const files = await res.json();
                const pngFiles = files.filter(f => f.name.toLowerCase().endsWith('.png')).map(f => f.name).sort((a,b) => a.localeCompare(b));
                if (pngFiles.length > 0) {
                    const firstPng = pngFiles[0];
                    const previewUrl = `https://raw.githubusercontent.com/${repo}/main/${folders.armor}/Png/${folderName}/${firstPng}`;
                    folderPreviews[folderName] = previewUrl;
                    imgElement.src = previewUrl;
                } else {
                    imgElement.src = 'https://placehold.co/100x100?text=Sem+Preview';
                }
            } catch (e) {
                console.error(`Erro ao carregar preview para ${folderName}: ${e.message}`);
                imgElement.src = 'https://placehold.co/100x100?text=Sem+Preview';
            }
        }

        async function loadArmor(name, type) {
            helmetToggle.classList.remove('disabled');
            let pngUrl, xmlUrl;

            if (type === 'single') {
                pngUrl = `${folders.armor}/Png/${name}.png`;
                xmlUrl = `${folders.armor}/Xml/${name}.xml`;
                helmetToggle.classList.add('disabled');
            } else {
                const repo = 'SuperMarco1321/MagicMontar.github.io';
                const apiUrl = `https://api.github.com/repos/${repo}/contents/${folders.armor}/Png/${name}`;
                try {
                    const res = await fetch(apiUrl);
                    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                    const files = await res.json();
                    const pngFiles = files.filter(f => f.name.toLowerCase().endsWith('.png')).map(f => f.name).sort((a,b) => a.localeCompare(b));
                    if (pngFiles.length === 0) throw new Error('Sem PNG');
                    const index = withHelmet ? 0 : Math.min(1, pngFiles.length - 1);
                    const selectedPng = pngFiles[index];
                    const baseName = selectedPng.replace('.png', '');
                    pngUrl = `${folders.armor}/Png/${name}/${selectedPng}`;
                    xmlUrl = `${folders.armor}/Xml/${name}/${baseName}.xml`;
                    if (pngFiles.length < 2) helmetToggle.classList.add('disabled');
                } catch (e) {
                    console.error(e);
                    document.getElementById('status').innerText = 'Erro ao carregar pasta de armadura.';
                    return;
                }
            }

            const fullPng = basePath + pngUrl;
            const fullXml = basePath + xmlUrl;

            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = fullPng;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = () => reject('Erro PNG');
            });

            data.armor = { img };

            try {
                const xmlText = await fetch(fullXml).then(r => r.ok ? r.text() : Promise.reject());
                data.armor.sprites = parseXML(xmlText);
            } catch {
                console.warn('XML não encontrado, usando apenas PNG');
                data.armor.sprites = [];
            }

            updatePreview();
        }

        async function loadAsset(type, name, folder, isWeapon) {
            const pngUrl = isWeapon ? `${folder}/Png/${name}.png` : `${folder}/Png/${name}.png`;
            const xmlUrl = isWeapon ? null : `${folder}/Xml/${name}.xml`;

            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = basePath + pngUrl;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
            });

            data[type] = { img };

            if (!isWeapon && xmlUrl) {
                try {
                    const xmlText = await fetch(basePath + xmlUrl).then(r => r.ok ? r.text() : Promise.reject());
                    data[type].sprites = parseXML(xmlText);
                } catch {
                    data[type].sprites = [];
                }
            }

            if (isWeapon) {
                const angulosUrl = basePath + 'Arma/Angulos.txt';
                try {
                    const text = await fetch(angulosUrl).then(r => r.text());
                    const bloco = text.match(new RegExp(`\\{[^}]*sprite\\s*=\\s*${name.replace('.', '\\.')};[^}]*\\}`));
                    if (bloco) {
                        const angle = bloco[0].match(/equippedAngle\s*=\s*([-\d.]+)/);
                        const ox = bloco[0].match(/equipOffsetX\s*=\s*([-\d]+)/);
                        const oy = bloco[0].match(/equipOffsetY\s*=\s*([-\d]+)/);
                        data[type].angle = angle ? parseFloat(angle[1]) : 0;
                        data[type].offset = [ox ? parseInt(ox[1]) : 0, oy ? parseInt(oy[1]) : 0];
                    }
                } catch {}
            }

            updatePreview();
        }

        function parseXML(text) {
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, "text/xml");
            const sprites = [];
            xml.querySelectorAll("sprite").forEach(s => {
                sprites.push({
                    name: s.getAttribute("n"),
                    x: parseInt(s.getAttribute("x")),
                    y: parseInt(s.getAttribute("y")),
                    w: parseInt(s.getAttribute("w")),
                    h: parseInt(s.getAttribute("h")),
                    oX: parseInt(s.getAttribute("oX") || 0),
                    oY: parseInt(s.getAttribute("oY") || 0),
                    oW: parseInt(s.getAttribute("oW") || 0),
                    oH: parseInt(s.getAttribute("oH") || 0),
                    pX: parseFloat(s.getAttribute("pX") || 0.5),
                    pY: parseFloat(s.getAttribute("pY") || 0.5)
                });
            });
            return sprites.sort((a, b) => a.name.localeCompare(b.name));
        }

        function tintImage(img, color) {
            const canvas = document.createElement("canvas");
            canvas.width = img.width; canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            ctx.globalCompositeOperation = "multiply";
            ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = "destination-atop";
            ctx.drawImage(img, 0, 0);
            return canvas;
        }

        function calcularPosicao(pivotX, pivotY, sprite) {
            if (!sprite) return [0, 0];
            const posX = pivotX - (sprite.pX * sprite.oW - sprite.oX);
            const posY = pivotY - (sprite.pY * sprite.oH - sprite.oY);
            return [posX, posY];
        }

        function montarFrame(frameIndex) {
            if (!data.body || !data.body.sprites || data.body.sprites.length === 0) return null;
            const bodySprite = data.body.sprites[frameIndex] || data.body.sprites[0];
            const pivotX = bodySprite.pX * bodySprite.oW;
            const pivotY = bodySprite.pY * bodySprite.oH;

            let bodyImg = data.body.img;
            if (bodyColor.r !== 255 || bodyColor.g !== 255 || bodyColor.b !== 255) {
                bodyImg = tintImage(bodyImg, bodyColor);
            }
            const bodyCrop = cropImage(bodyImg, bodySprite.x, bodySprite.y, bodySprite.w, bodySprite.h);
            const bodyPos = calcularPosicao(pivotX, pivotY, bodySprite);

            const crops = [{ img: bodyCrop, pos: bodyPos, key: 'body' }];

            ['armor', 'amuleto', 'pet', 'head'].forEach(key => {
                if (data[key] && data[key].sprites && data[key].sprites.length > 0) {
                    const s = data[key].sprites[Math.min(frameIndex, data[key].sprites.length - 1)];
                    const crop = cropImage(data[key].img, s.x, s.y, s.w, s.h);
                    const pos = calcularPosicao(pivotX, pivotY, s);
                    crops.push({ img: crop, pos, key });
                }
            });

            if (data.eye && data.eye.sprites && data.eye.sprites.length > 0) {
                const s = data.eye.sprites[Math.min(frameIndex, data.eye.sprites.length - 1)];
                let eyeCrop = cropImage(data.eye.img, s.x, s.y, s.w, s.h);
                if (eyeColor.r !== 255 || eyeColor.g !== 255 || eyeColor.b !== 255) {
                    eyeCrop = tintImage(eyeCrop, eyeColor);
                }
                const pos = calcularPosicao(pivotX, pivotY, s);
                crops.push({ img: eyeCrop, pos, key: 'eye' });
            }

            if (data.weapon) {
                const weaponImg = rotateImage(data.weapon.img, data.weapon.angle || 0);
                const pos = [pivotX + (data.weapon.offset?.[0] || 0) - weaponImg.width / 2,
                             pivotY + (data.weapon.offset?.[1] || 0) - weaponImg.height / 2];
                crops.push({ img: weaponImg, pos, key: 'weapon' });
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            crops.forEach(c => {
                minX = Math.min(minX, c.pos[0]);
                minY = Math.min(minY, c.pos[1]);
                maxX = Math.max(maxX, c.pos[0] + c.img.width);
                maxY = Math.max(maxY, c.pos[1] + c.img.height);
            });

            const canvas = document.createElement("canvas");
            canvas.width = Math.ceil(maxX - minX) || 1;
            canvas.height = Math.ceil(maxY - minY) || 1;
            const ctx = canvas.getContext("2d");

            const order = ['weapon', 'body', 'armor', 'amuleto', 'pet', 'head'];
            order.forEach(k => {
                const c = crops.find(crop => crop.key === k);
                if (c) ctx.drawImage(c.img, c.pos[0] - minX, c.pos[1] - minY);
            });

            const eye = crops.find(c => c.key === 'eye');
            if (eye) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.drawImage(eye.img, eye.pos[0] - minX, eye.pos[1] - minY);
            }

            return canvas;
        }

        function cropImage(img, x, y, w, h) {
            const canvas = document.createElement("canvas");
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
            return canvas;
        }

        function rotateImage(img, angle) {
            const rad = angle * Math.PI / 180;
            const sin = Math.abs(Math.sin(rad));
            const cos = Math.abs(Math.cos(rad));
            const canvas = document.createElement("canvas");
            canvas.width = img.width * cos + img.height * sin;
            canvas.height = img.width * sin + img.height * cos;
            const ctx = canvas.getContext("2d");
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rad);
            ctx.drawImage(img, -img.width / 2, -img.height / 2);
            return canvas;
        }

        async function updatePreview() {
            bodyColor = hexToRgb(document.getElementById('bodyColor').value);
            eyeColor = hexToRgb(document.getElementById('eyeColor').value);
            const canvas = montarFrame(0);
            if (canvas) {
                const prev = document.getElementById('preview');
                prev.width = canvas.width;
                prev.height = canvas.height;
                prev.getContext("2d").drawImage(canvas, 0, 0);
                document.getElementById('status').innerText = 'Preview atualizado!';
            } else {
                document.getElementById('status').innerText = 'Selecione um corpo primeiro.';
            }
        }

        async function generateAll() {
            if (!data.body || !data.body.sprites) {
                document.getElementById('status').innerText = 'Selecione um corpo primeiro.';
                return;
            }
            const zip = new JSZip();
            const total = data.body.sprites.length;
            document.getElementById('status').innerText = 'Gerando ZIP...';
            for (let i = 0; i < total; i++) {
                const canvas = montarFrame(i);
                const blob = await new Promise(r => canvas.toBlob(r));
                zip.file(`${data.body.sprites[i].name.replace(/[\\/]/g, '_')}.png`, blob);
            }
            const content = await zip.generateAsync({type: 'blob'});
            saveAs(content, 'Personagem_MagicRampage.zip');
            document.getElementById('status').innerText = 'ZIP gerado e baixado!';
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1,3),16);
            const g = parseInt(hex.slice(3,5),16);
            const b = parseInt(hex.slice(5,7),16);
            return {r, g, b};
        }

        async function loadCatalog() {
            try {
                const res = await fetch(basePath + 'catalog.json');
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                catalog = await res.json();

                const armorList = [];

                catalog.armor.folders.forEach(name => armorList.push({name, type: 'folder', display: name}));
                catalog.armor.single.forEach(name => armorList.push({name, type: 'single', display: name.replace(/_/g, ' ')}));

                armorList.sort((a,b) => a.display.localeCompare(b.display));

                createCatalog('bodyCatalog', catalog.body.map(n=>({name:n})), folders.body);
                createCatalog('armorCatalog', armorList, folders.armor);
                createCatalog('amuletoCatalog', catalog.amuleto.map(n=>({name:n})), folders.amuleto);
                createCatalog('petCatalog', catalog.pet.map(n=>({name:n})), folders.pet);
                createCatalog('headCatalog', catalog.head.map(n=>({name:n})), folders.head);
                createCatalog('eyeCatalog', catalog.eye.map(n=>({name:n})), folders.eye);
                createCatalog('weaponCatalog', catalog.weapon.map(n=>({name:n})), folders.weapon, true);

                document.getElementById('status').innerText = 'Catálogo carregado! Selecione as imagens.';
            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = 'Erro ao carregar catalog.json';
            }
        }

        window.onload = loadCatalog;
    </script>
</body>
</html>

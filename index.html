<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montador Magic Rampage - By Marco</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #111; color: #fff; padding: 20px; text-align: center; }
        h1 { color: #ffcc00; }
        h2 { color: #ddd; margin-top: 30px; }
        .catalog { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; margin: 20px auto; max-width: 1200px; }
        .item { background: #222; padding: 10px; border-radius: 8px; cursor: pointer; transition: 0.3s; }
        .item:hover { background: #333; }
        .item img { width: 100%; height: 100px; object-fit: contain; image-rendering: pixelated; background: rgba(0,0,0,0.5); border-radius: 5px; }
        .item span { display: block; margin-top: 5px; font-size: 0.8em; text-transform: capitalize; }
        .item.selected { border: 3px solid #ffcc00; }
        canvas { border: 2px solid #444; margin: 20px auto; display: block; image-rendering: pixelated; max-width: 100%; background: #000; }
        button { padding: 15px 30px; background: #ffcc00; color: #000; border: none; font-size: 18px; cursor: pointer; margin: 10px; border-radius: 8px; }
        button:hover { background: #ffdd44; }
        label { display: block; margin: 10px 0; }
        input[type="color"] { width: 50px; height: 30px; }
        #status { margin: 20px; font-size: 1.2em; color: #bbb; }
        #helmetToggle { padding: 10px 20px; background: #ffcc00; color: #000; font-size: 16px; margin: 10px auto; display: inline-block; border-radius: 8px; cursor: pointer; }
        #helmetToggle.disabled { background: #555; color: #888; cursor: not-allowed; }
    </style>
</head>
<body>
    <h1>Montador de Personagens Magic Rampage</h1>
    <p>Criado por Marco para a comunidade! Clique nas imagens para selecionar.</p>

    <label>Cor do corpo: <input type="color" id="bodyColor" value="#ffffff"></label>
    <label>Cor dos olhos: <input type="color" id="eyeColor" value="#ffffff"></label>

    <h2>Corpo (obrigatório)</h2>
    <div class="catalog" id="bodyCatalog"></div>

    <h2>Armadura</h2>
    <button id="helmetToggle">Com Elmo</button>
    <div class="catalog" id="armorCatalog"></div>

    <h2>Amuleto</h2>
    <div class="catalog" id="amuletoCatalog"></div>

    <h2>Pet</h2>
    <div class="catalog" id="petCatalog"></div>

    <h2>Cabeça</h2>
    <div class="catalog" id="headCatalog"></div>

    <h2>Olhos (com brilho additive)</h2>
    <div class="catalog" id="eyeCatalog"></div>

    <h2>Arma</h2>
    <div class="catalog" id="weaponCatalog"></div>

    <button onclick="updatePreview()">Atualizar Preview</button>
    <button onclick="generateAll()">Gerar ZIP Completo</button>

    <canvas id="preview" width="400" height="400"></canvas>
    <p id="status">Carregando catálogo...</p>

    <script>
        const basePath = '';
        const folders = {
            body: 'Corpo',
            armor: 'Armaduras',
            amuleto: 'Amuleto',
            pet: 'Pet',
            head: 'Cabeça',
            eye: 'Olho',
            weapon: 'Arma'
        };

        let catalog = {};
        let selected = {};
        let data = {};
        let bodyColor = {r: 255, g: 255, b: 255};
        let eyeColor = {r: 255, g: 255, b: 255};
        let withHelmet = true;

        const helmetToggle = document.getElementById('helmetToggle');
        helmetToggle.onclick = () => {
            if (helmetToggle.classList.contains('disabled')) return;
            withHelmet = !withHelmet;
            helmetToggle.textContent = withHelmet ? 'Com Elmo' : 'Sem Elmo';
            if (selected.armor) loadArmor(selected.armor);
        };

        function createCatalog(catId, list, folder, isWeapon = false) {
            const cat = document.getElementById(catId);
            cat.innerHTML = '';
            list.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'item';
                div.onclick = () => {
                    document.querySelectorAll(`#${catId} .selected`).forEach(el => el.classList.remove('selected'));
                    div.classList.add('selected');
                    if (catId === 'armorCatalog') {
                        selected.armor = entry;
                        loadArmor(entry);
                    } else {
                        selected[catId.replace('Catalog', '')] = entry.name;
                        loadAsset(catId.replace('Catalog', ''), entry.name, folder, isWeapon);
                    }
                };
                const img = document.createElement('img');
                if (catId === 'armorCatalog' && entry.type === 'folder') {
                    img.src = basePath + `${folders.armor}/Png/${entry.name}/${entry.with_helmet}.png`;
                } else {
                    img.src = basePath + `${folder}/Png/${entry.name}.png`;
                }
                img.onerror = () => img.src = 'https://placehold.it/100x100?text=Erro';
                div.appendChild(img);
                const span = document.createElement('span');
                span.innerText = (entry.display || entry.name).replace(/_/g, ' ');
                div.appendChild(span);
                cat.appendChild(div);
            });
        }

        function tryUpdatePreview() {
            if (data.armor && data.armor.img.complete && data.armor.sprites && data.armor.sprites.length > 0) {
                updatePreview();
            }
        }

        async function loadArmor(entry) {
            document.getElementById('status').innerText = 'Carregando armadura...';
            helmetToggle.classList.remove('disabled');
            let pngUrl, xmlUrl, baseName;

            if (entry.type === 'single') {
                baseName = entry.name;
                pngUrl = `${folders.armor}/Png/${baseName}.png`;
                xmlUrl = `${folders.armor}/Xml/${baseName}.xml`;
                helmetToggle.classList.add('disabled');
            } else { // folder
                baseName = withHelmet ? entry.with_helmet : entry.without_helmet;
                pngUrl = `${folders.armor}/Png/${entry.name}/${baseName}.png`;
                xmlUrl = `${folders.armor}/Xml/${entry.name}/${baseName}.xml`;
                if (entry.with_helmet === entry.without_helmet) {
                    helmetToggle.classList.add('disabled');
                }
            }

            // Reset armor data
            data.armor = { img: new Image(), sprites: null, loaded: false };

            data.armor.img.src = basePath + pngUrl;
            data.armor.img.onload = () => {
                data.armor.loaded = true;
                tryUpdatePreview();
            };
            data.armor.img.onerror = () => {
                document.getElementById('status').innerText = 'Erro ao carregar PNG da armadura.';
            };

            fetch(basePath + xmlUrl)
                .then(res => {
                    if (!res.ok) throw new Error('XML não encontrado');
                    return res.text();
                })
                .then(xml => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xml, "text/xml");
                    data.armor.sprites = Array.from(doc.getElementsByTagName('sprite')).map(s => ({
                        name: s.getAttribute('n'),
                        x: parseInt(s.getAttribute('x')),
                        y: parseInt(s.getAttribute('y')),
                        w: parseInt(s.getAttribute('w')),
                        h: parseInt(s.getAttribute('h')),
                        oX: parseInt(s.getAttribute('oX') || 0),
                        oY: parseInt(s.getAttribute('oY') || 0),
                        oW: parseInt(s.getAttribute('oW') || 0),
                        oH: parseInt(s.getAttribute('oH') || 0),
                        pX: parseFloat(s.getAttribute('pX') || 0.5),
                        pY: parseFloat(s.getAttribute('pY') || 0.5)
                    }));
                    tryUpdatePreview();
                })
                .catch(e => {
                    console.error('Erro ao carregar XML de armadura:', e);
                    document.getElementById('status').innerText = 'Erro ao carregar XML da armadura.';
                    data.armor.sprites = [];
                });
        }

        function loadAsset(key, name, folder, isWeapon = false) {
            data[key] = {img: new Image(), sprites: []};
            data[key].img.src = basePath + `${folder}/Png/${name}.png`;
            data[key].img.onload = () => updatePreview();
            if (!isWeapon) {
                fetch(basePath + `${folder}/Xml/${name}.xml`)
                    .then(res => res.text())
                    .then(xml => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(xml, "text/xml");
                        data[key].sprites = Array.from(doc.getElementsByTagName('sprite')).map(s => ({
                            name: s.getAttribute('n'),
                            x: parseInt(s.getAttribute('x')),
                            y: parseInt(s.getAttribute('y')),
                            w: parseInt(s.getAttribute('w')),
                            h: parseInt(s.getAttribute('h')),
                            oX: parseInt(s.getAttribute('oX') || 0),
                            oY: parseInt(s.getAttribute('oY') || 0),
                            oW: parseInt(s.getAttribute('oW') || 0),
                            oH: parseInt(s.getAttribute('oH') || 0),
                            pX: parseFloat(s.getAttribute('pX') || 0.5),
                            pY: parseFloat(s.getAttribute('pY') || 0.5)
                        }));
                        updatePreview();
                    })
                    .catch(e => console.error('Erro XML:', e));
            }
        }

        function tintImage(img, color) {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            ctx.globalCompositeOperation = "multiply";
            ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = "destination-atop";
            ctx.drawImage(img, 0, 0);
            return canvas;
        }

        function calcularPosicao(pivotX, pivotY, sprite) {
            if (!sprite) return [0, 0];
            const posX = pivotX - (sprite.pX * sprite.oW - sprite.oX);
            const posY = pivotY - (sprite.pY * sprite.oH - sprite.oY);
            return [posX, posY];
        }

        function montarFrame(frameIndex) {
            if (!data.body || !data.body.sprites || data.body.sprites.length === 0) return null;
            const bodySprite = data.body.sprites[frameIndex] || data.body.sprites[0];
            const pivotX = bodySprite.pX * bodySprite.oW;
            const pivotY = bodySprite.pY * bodySprite.oH;

            let bodyImg = data.body.img;
            if (bodyColor.r !== 255 || bodyColor.g !== 255 || bodyColor.b !== 255) {
                bodyImg = tintImage(bodyImg, bodyColor);
            }
            const bodyCrop = cropImage(bodyImg, bodySprite.x, bodySprite.y, bodySprite.w, bodySprite.h);
            const bodyPos = calcularPosicao(pivotX, pivotY, bodySprite);

            const crops = [{ img: bodyCrop, pos: bodyPos, key: 'body' }];

            ['armor', 'amuleto', 'pet', 'head'].forEach(key => {
                if (data[key] && data[key].sprites && data[key].sprites.length > 0) {
                    const s = data[key].sprites[Math.min(frameIndex, data[key].sprites.length - 1)];
                    const crop = cropImage(data[key].img, s.x, s.y, s.w, s.h);
                    const pos = calcularPosicao(pivotX, pivotY, s);
                    crops.push({ img: crop, pos, key });
                }
            });

            if (data.eye && data.eye.sprites && data.eye.sprites.length > 0) {
                const s = data.eye.sprites[Math.min(frameIndex, data.eye.sprites.length - 1)];
                let eyeCrop = cropImage(data.eye.img, s.x, s.y, s.w, s.h);
                if (eyeColor.r !== 255 || eyeColor.g !== 255 || eyeColor.b !== 255) {
                    eyeCrop = tintImage(eyeCrop, eyeColor);
                }
                const pos = calcularPosicao(pivotX, pivotY, s);
                crops.push({ img: eyeCrop, pos, key: 'eye' });
            }

            if (data.weapon) {
                const weaponImg = rotateImage(data.weapon.img, data.weapon.angle || 0);
                const pos = [pivotX + (data.weapon.offset?.[0] || 0) - weaponImg.width / 2,
                             pivotY + (data.weapon.offset?.[1] || 0) - weaponImg.height / 2];
                crops.push({ img: weaponImg, pos, key: 'weapon' });
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            crops.forEach(c => {
                minX = Math.min(minX, c.pos[0]);
                minY = Math.min(minY, c.pos[1]);
                maxX = Math.max(maxX, c.pos[0] + c.img.width);
                maxY = Math.max(maxY, c.pos[1] + c.img.height);
            });

            const canvas = document.createElement("canvas");
            canvas.width = Math.ceil(maxX - minX) || 1;
            canvas.height = Math.ceil(maxY - minY) || 1;
            const ctx = canvas.getContext("2d");

            const order = ['weapon', 'body', 'armor', 'amuleto', 'pet', 'head'];
            order.forEach(k => {
                const c = crops.find(crop => crop.key === k);
                if (c) ctx.drawImage(c.img, c.pos[0] - minX, c.pos[1] - minY);
            });

            const eye = crops.find(c => c.key === 'eye');
            if (eye) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.drawImage(eye.img, eye.pos[0] - minX, eye.pos[1] - minY);
            }

            return canvas;
        }

        function cropImage(img, x, y, w, h) {
            const canvas = document.createElement("canvas");
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
            return canvas;
        }

        function rotateImage(img, angle) {
            const rad = angle * Math.PI / 180;
            const sin = Math.abs(Math.sin(rad));
            const cos = Math.abs(Math.cos(rad));
            const canvas = document.createElement("canvas");
            canvas.width = img.width * cos + img.height * sin;
            canvas.height = img.width * sin + img.height * cos;
            const ctx = canvas.getContext("2d");
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rad);
            ctx.drawImage(img, -img.width / 2, -img.height / 2);
            return canvas;
        }

        function updatePreview() {
            bodyColor = hexToRgb(document.getElementById('bodyColor').value);
            eyeColor = hexToRgb(document.getElementById('eyeColor').value);
            const canvas = montarFrame(0);
            if (canvas) {
                const prev = document.getElementById('preview');
                prev.width = canvas.width;
                prev.height = canvas.height;
                prev.getContext("2d").drawImage(canvas, 0, 0);
                document.getElementById('status').innerText = 'Preview atualizado!';
            } else {
                document.getElementById('status').innerText = 'Selecione um corpo primeiro.';
            }
        }

        async function generateAll() {
            if (!data.body || !data.body.sprites) {
                document.getElementById('status').innerText = 'Selecione um corpo primeiro.';
                return;
            }
            const zip = new JSZip();
            const total = data.body.sprites.length;
            document.getElementById('status').innerText = 'Gerando ZIP... (pode demorar)';
            for (let i = 0; i < total; i++) {
                const canvas = montarFrame(i);
                const blob = await canvas.toBlob();
                zip.file(`${data.body.sprites[i].name.replace(/[\\/]/g, '_')}.png`, blob);
            }
            const content = await zip.generateAsync({type: 'blob'});
            saveAs(content, 'Personagem_MagicRampage.zip');
            document.getElementById('status').innerText = 'ZIP gerado e baixado!';
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1,3),16);
            const g = parseInt(hex.slice(3,5),16);
            const b = parseInt(hex.slice(5,7),16);
            return {r, g, b};
        }

        async function loadCatalog() {
            try {
                const res = await fetch(basePath + 'catalog.json');
                if (!res.ok) throw new Error();
                catalog = await res.json();

                const armorList = [];

                catalog.armor.folders.forEach(folder => {
                    armorList.push({
                        name: folder.name,
                        type: 'folder',
                        display: folder.name,
                        with_helmet: folder.with_helmet,
                        without_helmet: folder.without_helmet
                    });
                });
                catalog.armor.single.forEach(name => {
                    armorList.push({
                        name: name,
                        type: 'single',
                        display: name.replace(/_/g, ' ')
                    });
                });

                armorList.sort((a,b) => a.display.localeCompare(b.display));

                createCatalog('bodyCatalog', catalog.body.map(n=>({name:n})), folders.body);
                createCatalog('armorCatalog', armorList, folders.armor);
                createCatalog('amuletoCatalog', catalog.amuleto.map(n=>({name:n})), folders.amuleto);
                createCatalog('petCatalog', catalog.pet.map(n=>({name:n})), folders.pet);
                createCatalog('headCatalog', catalog.head.map(n=>({name:n})), folders.head);
                createCatalog('eyeCatalog', catalog.eye.map(n=>({name:n})), folders.eye);
                createCatalog('weaponCatalog', catalog.weapon.map(n=>({name:n})), folders.weapon, true);

                document.getElementById('status').innerText = 'Catálogo carregado! Selecione as imagens.';
            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = 'Erro ao carregar catalog.json';
            }
        }

        window.onload = loadCatalog;
    </script>
</body>
</html>

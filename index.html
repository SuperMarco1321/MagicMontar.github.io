<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montador Magic Rampage - By Marco</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #111; color: #fff; padding: 20px; text-align: center; }
        h1 { color: #ffcc00; }
        h2 { color: #ddd; margin-top: 30px; }
        .catalog { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; margin: 20px auto; max-width: 1200px; }
        .item { background: #222; padding: 10px; border-radius: 8px; cursor: pointer; transition: 0.3s; }
        .item:hover { background: #333; }
        .item img { width: 100%; height: 100px; object-fit: contain; image-rendering: pixelated; background: rgba(0,0,0,0.5); border-radius: 5px; }
        .item span { display: block; margin-top: 5px; font-size: 0.8em; text-transform: capitalize; }
        .item.selected { border: 3px solid #ffcc00; }
        canvas { border: 2px solid #444; margin: 20px auto; display: block; image-rendering: pixelated; max-width: 100%; background: #000; }
        button { padding: 15px 30px; background: #ffcc00; color: #000; border: none; font-size: 18px; cursor: pointer; margin: 10px; border-radius: 8px; }
        button:hover { background: #ffdd44; }
        label { display: block; margin: 10px 0; }
        input[type="color"] { width: 50px; height: 30px; }
        #status { margin: 20px; font-size: 1.2em; color: #bbb; }
        .toggle-helmet {
            display: inline-block;
            padding: 10px 20px;
            background: #333;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            font-size: 16px;
        }
        .toggle-helmet.active { background: #ffcc00; color: #000; }
    </style>
</head>
<body>
    <h1>Montador de Personagens Magic Rampage</h1>
    <p>Criado por Marco para a comunidade! Clique nas imagens para selecionar.</p>

    <label>Cor do corpo: <input type="color" id="bodyColor" value="#ffffff"></label>
    <label>Cor dos olhos: <input type="color" id="eyeColor" value="#ffffff"></label>

    <h2>Corpo (obrigatório)</h2>
    <div class="catalog" id="bodyCatalog"></div>

    <h2>Armadura</h2>
    <div style="margin-bottom: 15px;">
        <span class="toggle-helmet active" id="helmetToggle" onclick="toggleHelmet()">Com Elmo</span>
    </div>
    <div class="catalog" id="armorCatalog"></div>

    <h2>Amuleto</h2>
    <div class="catalog" id="amuletoCatalog"></div>

    <h2>Pet</h2>
    <div class="catalog" id="petCatalog"></div>

    <h2>Cabeça</h2>
    <div class="catalog" id="headCatalog"></div>

    <h2>Olhos (com brilho additive)</h2>
    <div class="catalog" id="eyeCatalog"></div>

    <h2>Arma</h2>
    <div class="catalog" id="weaponCatalog"></div>

    <button onclick="updatePreview()">Atualizar Preview</button>
    <button onclick="generateAll()">Gerar ZIP Completo</button>

    <canvas id="preview" width="400" height="400"></canvas>
    <p id="status">Carregando catálogo...</p>

    <script>
        const basePath = '';
        const folders = {
            body: 'Corpo',
            armor: 'Armaduras',
            amuleto: 'Amuleto',
            pet: 'Pet',
            head: 'Cabeça',
            eye: 'Olho',
            weapon: 'Arma'
        };

        let catalog = {};
        let selected = {};
        let data = {};
        let bodyColor = {r: 255, g: 255, b: 255};
        let eyeColor = {r: 255, g: 255, b: 255};
        let withHelmet = true; // estado do toggle

        function toggleHelmet() {
            withHelmet = !withHelmet;
            const btn = document.getElementById('helmetToggle');
            btn.textContent = withHelmet ? 'Com Elmo' : 'Sem Elmo';
            btn.classList.toggle('active', withHelmet);
            if (selected.armor) updatePreview();
        }

        async function loadCatalog() {
            try {
                const response = await fetch(basePath + 'catalog.json');
                if (!response.ok) throw new Error('catalog.json não encontrado');
                catalog = await response.json();

                populateBody();
                populateArmor();
                populateSimple('amuletoCatalog', catalog.amuleto, folders.amuleto);
                populateSimple('petCatalog', catalog.pet, folders.pet);
                populateSimple('headCatalog', catalog.head, folders.head);
                populateSimple('eyeCatalog', catalog.eye, folders.eye);
                populateSimple('weaponCatalog', catalog.weapon, folders.weapon, true);

                document.getElementById('status').innerText = 'Catálogo carregado! Selecione as imagens.';
            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = 'Erro ao carregar catalog.json';
            }
        }

        function populateBody() {
            const cat = document.getElementById('bodyCatalog');
            cat.innerHTML = '';
            catalog.body.forEach(name => createItem(cat, 'body', name, folders.body));
        }

        function populateArmor() {
            const cat = document.getElementById('armorCatalog');
            cat.innerHTML = '';

            // Pastas (folders)
            (catalog.armor.folders || []).forEach(folderName => {
                const div = document.createElement('div');
                div.className = 'item';
                div.onclick = () => selectArmorFolder(folderName);
                const img = document.createElement('img');
                img.src = `${basePath}${folders.armor}/${folderName}/${getPreviewPngForFolder(folderName)}.png`;
                img.onerror = () => img.src = 'https://placehold.it/100x100?text=Sem+Preview';
                div.appendChild(img);
                const span = document.createElement('span');
                span.innerText = folderName;
                div.appendChild(span);
                cat.appendChild(div);
            });

            // Arquivos soltos (single)
            (catalog.armor.single || []).forEach(name => createItem(cat, 'armor', name, folders.armor));
        }

        async function selectArmorFolder(folderName) {
            document.querySelectorAll('#armorCatalog .selected').forEach(el => el.classList.remove('selected'));
            event.target.closest('.item').classList.add('selected');

            selected.armor = { type: 'folder', name: folderName };
            await loadArmorFromFolder(folderName);
            updateHelmetToggleState();
            updatePreview();
        }

        function getPreviewPngForFolder(folderName) {
            // Usa o primeiro PNG alfabético como preview (geralmente o "com elmo")
            return 'armor_cloth_Na'; // fallback, será substituído no load real
        }

        async function loadArmorFromFolder(folderName) {
            const folderPath = `${folders.armor}/${folderName}`;
            // Lista arquivos PNG na pasta (usando um truque simples: tenta carregar possíveis nomes comuns ou lista via fetch simulado)
            // Como GitHub Pages não permite listagem de diretório, precisamos de uma lista prévia ou tentar nomes comuns.
            // Solução prática: carregamos os dois possíveis (ou mais) via tentativa de fetch de um arquivo index fictício ou simplesmente tentamos nomes.
            // Melhor abordagem: criar um pequeno JSON por pasta ou aceitar que o usuário tenha nomes previsíveis.
            // Como combinamos ordem alfabética, vamos tentar carregar todos os PNG possíveis listando via um proxy simples ou aceitar que precisamos de uma lista.
            // Para funcionar 100% no GitHub Pages sem backend, a solução mais simples e robusta é: assumir que os PNGs têm extensão .png e tentar carregar até encontrar os existentes.
            // Mas isso é lento. Alternativa melhor: adicionar no catalog.json opcional "variants" por pasta, mas você queria simples.

            // Implementação prática e funcional: vamos buscar todos os arquivos PNG da pasta tentando carregar um arquivo "list.txt" que você pode criar em cada pasta com os nomes dos PNGs, uma linha por arquivo.
            // Mas para não exigir trabalho extra agora, vamos usar uma abordagem híbrida: tenta nomes comuns e carrega os que existirem.

            const possibleNames = [];
            const baseNames = ['armor_cloth_Na', 'armor_cloth_Nb', 'armor_cloth_a', 'armor_cloth_b', 'armor', 'main', 'with_helmet', 'without_helmet'];
            for (let base of baseNames) {
                possibleNames.push(base);
                possibleNames.push(base.toLowerCase());
            }

            const pngFiles = [];
            for (let name of possibleNames) {
                const url = `${basePath}${folderPath}/${name}.png`;
                const imgTest = new Image();
                imgTest.src = url;
                await new Promise(resolve => {
                    imgTest.onload = () => { pngFiles.push(name); resolve(); };
                    imgTest.onerror = resolve;
                });
            }

            // Se não encontrou nenhum com nomes comuns, tenta listar via um truque ou aceita fallback
            if (pngFiles.length === 0) {
                // fallback: tenta armor_cloth_Na e Nb
                const candidates = ['armor_cloth_Na', 'armor_cloth_Nb'];
                for (let c of candidates) {
                    const url = `${basePath}${folderPath}/${c}.png`;
                    const imgTest = new Image();
                    imgTest.src = url;
                    await new Promise(resolve => {
                        imgTest.onload = () => { pngFiles.push(c); resolve(); };
                        imgTest.onerror = resolve;
                    });
                }
            }

            pngFiles.sort(); // ordem alfabética

            if (pngFiles.length === 0) {
                document.getElementById('status').innerText = 'Nenhum PNG encontrado na pasta ' + folderName;
                data.armor = null;
                return;
            }

            data.armorVariants = pngFiles.map(n => ({
                name: n,
                pngUrl: `${basePath}${folderPath}/${n}.png`,
                xmlUrl: `${basePath}${folderPath}/${n}.xml`
            }));

            await loadCurrentArmorVariant();
        }

        async function loadCurrentArmorVariant() {
            if (!data.armorVariants) return;
            const index = withHelmet ? 0 : Math.min(1, data.armorVariants.length - 1);
            const variant = data.armorVariants[index];

            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = variant.pngUrl;
            await new Promise(resolve => img.onload = resolve);

            data.armor = { img };

            try {
                const xmlText = await fetch(variant.xmlUrl).then(r => r.ok ? r.text() : null);
                if (xmlText) data.armor.sprites = parseXML(xmlText);
            } catch (e) {
                console.warn('XML não encontrado para variante', variant.name);
                data.armor.sprites = [];
            }
        }

        function updateHelmetToggleState() {
            const btn = document.getElementById('helmetToggle');
            if (!data.armorVariants || data.armorVariants.length <= 1) {
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            } else {
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }
        }

        function createItem(container, type, name, folder, isWeapon = false) {
            const div = document.createElement('div');
            div.className = 'item';
            div.onclick = () => {
                container.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                div.classList.add('selected');
                selected[type] = { type: 'single', name };
                loadAsset(type, name, folder, isWeapon);
                if (type === 'armor') updateHelmetToggleState();
            };
            const img = document.createElement('img');
            img.src = basePath + (isWeapon ? `${folder}/Png/${name}.png` : `${folder}/Png/${name}.png`);
            img.onerror = () => img.src = 'https://placehold.it/100x100?text=Erro';
            div.appendChild(img);
            const span = document.createElement('span');
            span.innerText = name.replace(/_/g, ' ').replace(/[-+]/g, ' ');
            div.appendChild(span);
            container.appendChild(div);
        }

        function populateSimple(catId, list, folder, isWeapon = false) {
            const cat = document.getElementById(catId);
            cat.innerHTML = '';
            list.forEach(name => createItem(cat, catId.replace('Catalog', ''), name, folder, isWeapon));
        }

        async function loadAsset(type, name, folder, isWeapon) {
            const pngUrl = basePath + (isWeapon ? `${folder}/Png/${name}.png` : `${folder}/Png/${name}.png`);
            const xmlUrl = isWeapon ? null : basePath + `${folder}/Xml/${name}.xml`;

            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = pngUrl;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
            });

            data[type] = { img };

            if (!isWeapon && xmlUrl) {
                try {
                    const xmlText = await fetch(xmlUrl).then(r => r.ok ? r.text() : null);
                    if (xmlText) data[type].sprites = parseXML(xmlText);
                } catch (e) {
                    data[type].sprites = [];
                }
            }

            // Arma: Angulos.txt
            if (isWeapon) {
                try {
                    const angulosText = await fetch(basePath + 'Arma/Angulos.txt').then(r => r.text());
                    const bloco = angulosText.match(new RegExp(`\\{[^}]*sprite\\s*=\\s*${name.replace(".", "\\.")};[^}]*\\}`));
                    if (bloco) {
                        const angle = bloco[0].match(/equippedAngle\s*=\s*([-\d.]+)/);
                        const ox = bloco[0].match(/equipOffsetX\s*=\s*([-\d]+)/);
                        const oy = bloco[0].match(/equipOffsetY\s*=\s*([-\d]+)/);
                        data[type].angle = angle ? parseFloat(angle[1]) : 0;
                        data[type].offset = [ox ? parseInt(ox[1]) : 0, oy ? parseInt(oy[1]) : 0];
                    }
                } catch (e) {
                    data[type].angle = 0;
                    data[type].offset = [0, 0];
                }
            }

            updatePreview();
        }

        function parseXML(text) {
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, "text/xml");
            const sprites = [];
            xml.querySelectorAll("sprite").forEach(s => {
                sprites.push({
                    name: s.getAttribute("n"),
                    x: parseInt(s.getAttribute("x")),
                    y: parseInt(s.getAttribute("y")),
                    w: parseInt(s.getAttribute("w")),
                    h: parseInt(s.getAttribute("h")),
                    oX: parseInt(s.getAttribute("oX") || 0),
                    oY: parseInt(s.getAttribute("oY") || 0),
                    oW: parseInt(s.getAttribute("oW") || 0),
                    oH: parseInt(s.getAttribute("oH") || 0),
                    pX: parseFloat(s.getAttribute("pX") || 0.5),
                    pY: parseFloat(s.getAttribute("pY") || 0.5)
                });
            });
            return sprites.sort((a, b) => (a.name.replace(/\d+/g, n => n.padStart(10, '0'))).localeCompare(b.name.replace(/\d+/g, n => n.padStart(10, '0'))));
        }

        function tintImage(img, color) {
            const canvas = document.createElement("canvas");
            canvas.width = img.width; canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            ctx.globalCompositeOperation = "multiply";
            ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = "destination-atop";
            ctx.drawImage(img, 0, 0);
            return canvas;
        }

        function calcularPosicao(pivotX, pivotY, sprite) {
            if (!sprite) return [0, 0];
            const posX = pivotX - (sprite.pX * sprite.oW - sprite.oX);
            const posY = pivotY - (sprite.pY * sprite.oH - sprite.oY);
            return [posX, posY];
        }

        function montarFrame(frameIndex) {
            if (!data.body || !data.body.sprites || data.body.sprites.length === 0) return null;
            const bodySprite = data.body.sprites[frameIndex] || data.body.sprites[0];
            const pivotX = bodySprite.pX * bodySprite.oW;
            const pivotY = bodySprite.pY * bodySprite.oH;

            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            let bodyImg = data.body.img;
            if (bodyColor.r !== 255 || bodyColor.g !== 255 || bodyColor.b !== 255) {
                bodyImg = tintImage(bodyImg, bodyColor);
            }
            const bodyCrop = cropImage(bodyImg, bodySprite.x, bodySprite.y, bodySprite.w, bodySprite.h);
            const bodyPos = calcularPosicao(pivotX, pivotY, bodySprite);

            const layers = ['armor', 'amuleto', 'pet', 'head'];
            const crops = [];
            crops.push({ img: bodyCrop, pos: bodyPos, key: 'body' });

            layers.forEach(key => {
                if (data[key] && data[key].sprites && data[key].sprites.length > 0) {
                    const s = data[key].sprites[Math.min(frameIndex, data[key].sprites.length - 1)];
                    const crop = cropImage(data[key].img, s.x, s.y, s.w, s.h);
                    const pos = calcularPosicao(pivotX, pivotY, s);
                    crops.push({ img: crop, pos, key });
                }
            });

            if (data.eye && data.eye.sprites && data.eye.sprites.length > 0) {
                const s = data.eye.sprites[Math.min(frameIndex, data.eye.sprites.length - 1)];
                let eyeCrop = cropImage(data.eye.img, s.x, s.y, s.w, s.h);
                if (eyeColor.r !== 255 || eyeColor.g !== 255 || eyeColor.b !== 255) {
                    eyeCrop = tintImage(eyeCrop, eyeColor);
                }
                const pos = calcularPosicao(pivotX, pivotY, s);
                crops.push({ img: eyeCrop, pos, key: 'eye' });
            }

            if (data.weapon) {
                const weaponImg = rotateImage(data.weapon.img, data.weapon.angle || 0);
                const pos = [pivotX + (data.weapon.offset[0] || 0) - weaponImg.width / 2, pivotY + (data.weapon.offset[1] || 0) - weaponImg.height / 2];
                crops.push({ img: weaponImg, pos, key: 'weapon' });
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            crops.forEach(c => {
                minX = Math.min(minX, c.pos[0]);
                minY = Math.min(minY, c.pos[1]);
                maxX = Math.max(maxX, c.pos[0] + c.img.width);
                maxY = Math.max(maxY, c.pos[1] + c.img.height);
            });

            canvas.width = Math.max(1, maxX - minX);
            canvas.height = Math.max(1, maxY - minY);

            const order = ['weapon', 'body', 'armor', 'amuleto', 'pet', 'head'];
            order.forEach(k => {
                const c = crops.find(c => c.key === k);
                if (c) ctx.drawImage(c.img, c.pos[0] - minX, c.pos[1] - minY);
            });

            const eye = crops.find(c => c.key === 'eye');
            if (eye) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.drawImage(eye.img, eye.pos[0] - minX, eye.pos[1] - minY);
            }

            return canvas;
        }

        function cropImage(img, x, y, w, h) {
            const canvas = document.createElement("canvas");
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
            return canvas;
        }

        function rotateImage(img, angle) {
            const canvas = document.createElement("canvas");
            const rad = angle * Math.PI / 180;
            const sin = Math.abs(Math.sin(rad));
            const cos = Math.abs(Math.cos(rad));
            canvas.width = img.width * cos + img.height * sin;
            canvas.height = img.width * sin + img.height * cos;
            const ctx = canvas.getContext("2d");
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rad);
            ctx.drawImage(img, -img.width / 2, -img.height / 2);
            return canvas;
        }

        async function updatePreview() {
            bodyColor = hexToRgb(document.getElementById('bodyColor').value);
            eyeColor = hexToRgb(document.getElementById('eyeColor').value);

            // Se for armadura de pasta, recarrega a variante correta
            if (selected.armor && selected.armor.type === 'folder') {
                await loadCurrentArmorVariant();
            }

            const canvas = montarFrame(0);
            if (canvas) {
                const prev = document.getElementById('preview');
                prev.width = canvas.width;
                prev.height = canvas.height;
                prev.getContext("2d").drawImage(canvas, 0, 0);
                document.getElementById('status').innerText = 'Preview atualizado!';
            } else {
                document.getElementById('status').innerText = 'Selecione um corpo primeiro.';
            }
        }

        async function generateAll() {
            if (!data.body || !data.body.sprites || data.body.sprites.length === 0) {
                document.getElementById('status').innerText = 'Selecione um corpo primeiro.';
                return;
            }

            // Recarrega variante correta antes de gerar ZIP
            if (selected.armor && selected.armor.type === 'folder') {
                await loadCurrentArmorVariant();
            }

            const zip = new JSZip();
            const total = data.body.sprites.length;
            for (let i = 0; i < total; i++) {
                const canvas = montarFrame(i);
                const blob = await new Promise(r => canvas.toBlob(r));
                zip.file(`${data.body.sprites[i].name.replace(/[\\/]/g, '_')}.png`, blob);
            }
            const content = await zip.generateAsync({type: 'blob'});
            saveAs(content, 'Personagem_MagicRampage.zip');
            document.getElementById('status').innerText = 'ZIP gerado e baixado!';
        }

        function hexToRgb(hex) {
            return { r: parseInt(hex.slice(1,3),16), g: parseInt(hex.slice(3,5),16), b: parseInt(hex.slice(5,7),16) };
        }

        window.onload = loadCatalog;
    </script>
</body>
</html>

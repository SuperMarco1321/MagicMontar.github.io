<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montador Magic Rampage - Fornecido por Super Marco</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            background: #111; 
            color: #fff; 
            margin: 0; 
            padding: 0; 
            display: flex; 
            min-height: 100vh; 
        }
        h1 { color: #ffcc00; text-align: center; margin: 20px 0; }

        /* Menu lateral */
        #sidebar {
            width: 400px;
            background: #1a1a1a;
            border-right: 2px solid #444;
            overflow-y: auto;
            padding-bottom: 100px;
        }
        .colors {
            padding: 15px;
            text-align: center;
            background: #222;
            margin: 10px;
            border-radius: 8px;
        }
        .accordion-button {
            width: 100%;
            background: #222;
            color: #ffcc00;
            padding: 12px 15px;
            text-align: left;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
        }
        .accordion-button::after {
            content: '▼';
            font-size: 14px;
        }
        .accordion-button.active::after {
            content: '▲';
        }
        .accordion-button:hover { background: #333; }

        .panel {
            padding: 0 15px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
        }
        .catalog {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 15px 0;
        }
        .item {
            background: #222;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.3s;
        }
        .item:hover { background: #333; }
        .item img {
            width: 100%;
            height: 90px;
            object-fit: contain;
            image-rendering: pixelated;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
        }
        .item span {
            display: block;
            margin-top: 5px;
            font-size: 0.75em;
            text-transform: capitalize;
            text-align: center;
        }
        .item.selected { border: 3px solid #ffcc00; }

        /* Área do preview - sticky */
        #main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 40px;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            align-self: flex-start;
        }
        #previewContainer {
            margin-top: 20px;
        }
        canvas {
            border: 2px solid #444;
            image-rendering: pixelated;
            background: #000;
            max-width: 100%;
        }
        .buttons {
            margin: 20px 0;
        }
        button {
            padding: 12px 25px;
            background: #ffcc00;
            color: #000;
            border: none;
            font-size: 16px;
            cursor: pointer;
            margin: 0 10px;
            border-radius: 8px;
        }
        button:hover { background: #ffdd44; }
        #helmetToggle {
            padding: 10px 20px;
            background: #ffcc00;
            color: #000;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
        }
        #helmetToggle.disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }
        #status {
            margin: 15px 0;
            font-size: 1.2em;
            color: #bbb;
        }
        @media (max-width: 900px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; max-height: 60vh; }
            #main { padding: 20px; position: static; height: auto; }
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>Montador Magic Rampage</h1>
        <p style="text-align:center; margin-bottom:20px;">By Marco</p>

        <div class="colors">
            <label>Cor do corpo: <input type="color" id="bodyColor" value="#ffffff"></label><br><br>
            <label>Cor dos olhos: <input type="color" id="eyeColor" value="#ffffff"></label>
        </div>

        <button class="accordion-button">Corpo (obrigatório)</button>
        <div class="panel"><div class="catalog" id="bodyCatalog"></div></div>

        <button class="accordion-button">Armadura</button>
        <div class="panel">
            <div style="text-align:center; padding:10px;">
                <button id="helmetToggle">Com Elmo</button>
            </div>
            <div class="catalog" id="armorCatalog"></div>
        </div>

        <button class="accordion-button">Amuleto</button>
        <div class="panel"><div class="catalog" id="amuletoCatalog"></div></div>

        <button class="accordion-button">Pet</button>
        <div class="panel"><div class="catalog" id="petCatalog"></div></div>

        <button class="accordion-button">Cabeça</button>
        <div class="panel" id="headPanel">
            <h3 style="margin: 10px 0; color: #ddd;">Normais</h3>
            <div class="catalog" id="headNormalCatalog"></div>
            
            <h3 style="margin: 10px 0; color: #ddd;">Skins por Classe</h3>
            <div class="catalog" id="skinClassesCatalog"></div>
            
            <div id="skinVariationsContainer" style="display: none;">
                <button id="backToHeadClasses" style="margin-bottom: 10px; background: #444; color: #fff;">Voltar para Classes</button>
                <h3 id="selectedHeadClassTitle" style="margin: 10px 0; color: #ddd;"></h3>
                <div class="catalog" id="skinVariationsCatalog"></div>
            </div>
        </div>

        <button class="accordion-button">Olhos (brilho additive)</button>
        <div class="panel"><div class="catalog" id="eyeCatalog"></div></div>

        <button class="accordion-button">Arma</button>
        <div class="panel" id="weaponPanel">
            <h3 style="margin: 10px 0; color: #ddd;">Por Categoria</h3>
            <div class="catalog" id="weaponCategoriesCatalog"></div>
            
            <div id="weaponVariationsContainer" style="display: none;">
                <button id="backToWeaponCategories" style="margin-bottom: 10px; background: #444; color: #fff;">Voltar para Categorias</button>
                <h3 id="selectedWeaponCategoryTitle" style="margin: 10px 0; color: #ddd;"></h3>
                <div class="catalog" id="weaponVariationsCatalog"></div>
            </div>
        </div>
    </div>

    <div id="main">
        <div class="buttons">
            <button onclick="updatePreview()">Atualizar Preview</button>
            <button onclick="generateAll()">Gerar ZIP Completo</button>
        </div>
        <div id="status">Carregando catálogo...</div>
        <div id="previewContainer">
            <canvas id="preview" width="400" height="400"></canvas>
        </div>
    </div>

    <script>
        const basePath = '';
        const folders = {
            body: 'Corpo',
            armor: 'Armaduras',
            amuleto: 'Amuleto',
            pet: 'Pet',
            head: 'Cabeça',
            eye: 'Olho',
            weapon: 'Arma'
        };

        let catalog = {};
        let selected = {};
        let data = {};
        let bodyColor = {r: 255, g: 255, b: 255};
        let eyeColor = {r: 255, g: 255, b: 255};
        let withHelmet = true;
        let selectedSkinClass = null;
        let selectedWeaponCategory = null;
        let weaponConfigs = {};

        const helmetToggle = document.getElementById('helmetToggle');
        const bodyColorInput = document.getElementById('bodyColor');
        const eyeColorInput = document.getElementById('eyeColor');
        const backToHeadClasses = document.getElementById('backToHeadClasses');
        const backToWeaponCategories = document.getElementById('backToWeaponCategories');

        bodyColorInput.addEventListener('input', () => {
            bodyColor = hexToRgb(bodyColorInput.value);
            updatePreview();
        });

        eyeColorInput.addEventListener('input', () => {
            eyeColor = hexToRgb(eyeColorInput.value);
            updatePreview();
        });

        helmetToggle.onclick = () => {
            if (helmetToggle.classList.contains('disabled')) return;
            withHelmet = !withHelmet;
            helmetToggle.textContent = withHelmet ? 'Com Elmo' : 'Sem Elmo';
            if (selected.armor) loadArmor(selected.armor);
        };

        backToHeadClasses.onclick = () => {
            selectedSkinClass = null;
            document.getElementById('skinVariationsContainer').style.display = 'none';
            document.getElementById('skinClassesCatalog').style.display = 'grid';
            document.getElementById('headNormalCatalog').style.display = 'grid';
            delete selected.head;
            delete data.head;
            updatePreview();
        };

        backToWeaponCategories.onclick = () => {
            selectedWeaponCategory = null;
            document.getElementById('weaponVariationsContainer').style.display = 'none';
            document.getElementById('weaponCategoriesCatalog').style.display = 'grid';
            delete selected.weapon;
            delete data.weapon;
            updatePreview();
        };

        async function loadWeaponConfigs() {
            try {
                const res = await fetch(basePath + 'Arma/Angulos.txt');
                if (!res.ok) return;
                const txt = await res.text();
                const blocks = txt.match(/\{[\s\S]*?\}/g) || [];
                blocks.forEach(block => {
                    const spriteMatch = block.match(/sprite\s*=\s*([^\s;]+);/);
                    if (spriteMatch) {
                        const spriteName = spriteMatch[1].trim();
                        const name = spriteName.replace('.png', '');
                        const angleMatch = block.match(/equippedAngle\s*=\s*([-\d\.]+);/);
                        const offsetXMatch = block.match(/equipOffsetX\s*=\s*([-\d]+);/);
                        const offsetYMatch = block.match(/equipOffsetY\s*=\s*([-\d]+);/);
                        weaponConfigs[name] = {
                            angle: angleMatch ? parseFloat(angleMatch[1]) : 0,
                            offset: [
                                offsetXMatch ? parseInt(offsetXMatch[1]) : 0,
                                offsetYMatch ? parseInt(offsetYMatch[1]) : 0
                            ]
                        };
                    }
                });
            } catch (e) {
                console.warn('Angulos.txt não carregado:', e);
            }
        }

        function createCatalog(catId, list, folder, isWeapon = false, isSkinClass = false, isSkinVariation = false, isWeaponCategory = false, isWeaponVariation = false) {
            const cat = document.getElementById(catId);
            cat.innerHTML = '';
            list.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'item';
                div.onclick = () => {
                    const currentlySelected = cat.querySelector('.selected');
                    if (currentlySelected === div) {
                        div.classList.remove('selected');
                        if (isSkinClass) {
                            selectedSkinClass = null;
                            document.getElementById('skinVariationsContainer').style.display = 'none';
                            document.getElementById('skinClassesCatalog').style.display = 'grid';
                            document.getElementById('headNormalCatalog').style.display = 'grid';
                            delete selected.head;
                            delete data.head;
                        } else if (isWeaponCategory) {
                            selectedWeaponCategory = null;
                            document.getElementById('weaponVariationsContainer').style.display = 'none';
                            document.getElementById('weaponCategoriesCatalog').style.display = 'grid';
                            delete selected.weapon;
                            delete data.weapon;
                        } else if (isSkinVariation) {
                            delete selected.head;
                            delete data.head;
                        } else if (isWeaponVariation) {
                            delete selected.weapon;
                            delete data.weapon;
                        } else if (catId === 'armorCatalog') {
                            delete selected.armor;
                            delete data.armor;
                            helmetToggle.classList.add('disabled');
                        } else {
                            const key = catId.replace('Catalog', '').replace('Normal', '').replace('Classes', '').replace('Variations', '').replace('Categories', '');
                            delete selected[key];
                            delete data[key];
                        }
                    } else {
                        if (currentlySelected) currentlySelected.classList.remove('selected');
                        div.classList.add('selected');
                        if (isSkinClass) {
                            selectedSkinClass = entry;
                            document.getElementById('selectedHeadClassTitle').innerText = entry.class + ' Skins';
                            document.getElementById('skinVariationsContainer').style.display = 'block';
                            document.getElementById('skinClassesCatalog').style.display = 'none';
                            document.getElementById('headNormalCatalog').style.display = 'none';
                            createCatalog('skinVariationsCatalog', entry.variations.map(v => ({name: v, class_folder: entry.folder})), folders.head, false, false, true);
                        } else if (isWeaponCategory) {
                            selectedWeaponCategory = entry;
                            document.getElementById('selectedWeaponCategoryTitle').innerText = entry.category + ' Armas';
                            document.getElementById('weaponVariationsContainer').style.display = 'block';
                            document.getElementById('weaponCategoriesCatalog').style.display = 'none';
                            createCatalog('weaponVariationsCatalog', entry.variations.map(v => ({name: v, category_folder: entry.folder})), folders.weapon, true, false, false, false, true);
                        } else if (isSkinVariation) {
                            selected.head = {type: 'skin', name: entry.name, class_folder: entry.class_folder};
                            loadHeadAsset(entry.name, entry.class_folder);
                        } else if (catId === 'headNormalCatalog') {
                            selected.head = {type: 'normal', name: entry.name};
                            loadHeadAsset(entry.name);
                        } else if (isWeaponVariation) {
                            selected.weapon = {type: 'category', name: entry.name, category_folder: entry.category_folder};
                            loadWeaponAsset(entry.name, entry.category_folder);
                        } else if (catId === 'armorCatalog') {
                            selected.armor = entry;
                            loadArmor(entry);
                        } else {
                            const key = catId.replace('Catalog', '');
                            selected[key] = entry.name;
                            loadAsset(key, entry.name, folder, isWeapon);
                        }
                    }
                    updatePreview();
                };
                const img = document.createElement('img');
                if (isSkinClass) {
                    img.src = basePath + `${folders.head}/Png/Skins/${entry.folder}/${entry.preview_png}.png`;
                } else if (isSkinVariation) {
                    img.src = basePath + `${folders.head}/Png/Skins/${entry.class_folder}/${entry.name}.png`;
                } else if (isWeaponCategory) {
                    img.src = basePath + `${folders.weapon}/Png/${entry.folder}/${entry.preview_png}.png`;
                } else if (isWeaponVariation) {
                    img.src = basePath + `${folders.weapon}/Png/${entry.category_folder}/${entry.name}.png`;
                } else if (catId === 'armorCatalog' && entry.type === 'folder') {
                    img.src = basePath + `${folders.armor}/Png/${entry.name}/${entry.with_helmet}.png`;
                } else {
                    img.src = basePath + `${folder}/Png/${entry.name}.png`;
                }
                img.onerror = () => img.src = 'https://placehold.it/100x100?text=Erro';
                div.appendChild(img);
                const span = document.createElement('span');
                span.innerText = (entry.display || entry.class || entry.category || entry.name).replace(/_/g, ' ');
                div.appendChild(span);
                cat.appendChild(div);
            });
        }

        function loadHeadAsset(name, class_folder = null) {
            data.head = {img: new Image(), sprites: []};
            let pngUrl = class_folder ? `${folders.head}/Png/Skins/${class_folder}/${name}.png` : `${folders.head}/Png/${name}.png`;
            data.head.img.src = basePath + pngUrl;
            data.head.img.onload = () => updatePreview();
            fetch(basePath + `${folders.head}/Xml/${name}.xml`)
                .then(res => res.text())
                .then(xml => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xml, "text/xml");
                    data.head.sprites = Array.from(doc.getElementsByTagName('sprite')).map(s => ({
                        name: s.getAttribute('n'),
                        x: parseInt(s.getAttribute('x')),
                        y: parseInt(s.getAttribute('y')),
                        w: parseInt(s.getAttribute('w')),
                        h: parseInt(s.getAttribute('h')),
                        oX: parseInt(s.getAttribute('oX') || 0),
                        oY: parseInt(s.getAttribute('oY') || 0),
                        oW: parseInt(s.getAttribute('oW') || 0),
                        oH: parseInt(s.getAttribute('oH') || 0),
                        pX: parseFloat(s.getAttribute('pX') || 0.5),
                        pY: parseFloat(s.getAttribute('pY') || 0.5)
                    }));
                    updatePreview();
                })
                .catch(e => {
                    console.error('Erro XML head:', e);
                    delete data.head;
                    updatePreview();
                });
        }

        function loadWeaponAsset(name, category_folder = null) {
            data.weapon = {img: new Image()};
            let pngUrl = category_folder ? `${folders.weapon}/Png/${category_folder}/${name}.png` : `${folders.weapon}/Png/${name}.png`;
            data.weapon.img.src = basePath + pngUrl;
            data.weapon.img.onload = () => updatePreview();

            const config = weaponConfigs[name] || {angle: 0, offset: [0, 0]};
            data.weapon.angle = -config.angle;  // <--- CORREÇÃO: inverte o sinal para combinar com o Python
            data.weapon.offset = config.offset;

            updatePreview();
        }

        async function loadArmor(entry) {
            helmetToggle.classList.remove('disabled');
            let pngUrl, xmlUrl, baseName;

            if (entry.type === 'single') {
                baseName = entry.name;
                pngUrl = `${folders.armor}/Png/${baseName}.png`;
                xmlUrl = `${folders.armor}/Xml/${baseName}.xml`;
                helmetToggle.classList.add('disabled');
            } else {
                baseName = withHelmet ? entry.with_helmet : entry.without_helmet;
                pngUrl = `${folders.armor}/Png/${entry.name}/${baseName}.png`;
                xmlUrl = `${folders.armor}/Xml/${baseName}.xml`;
                if (entry.with_helmet === entry.without_helmet) {
                    helmetToggle.classList.add('disabled');
                }
            }

            data.armor = {img: new Image(), sprites: []};
            data.armor.img.src = basePath + pngUrl;
            data.armor.img.onload = () => updatePreview();

            fetch(basePath + xmlUrl)
                .then(res => {
                    if (!res.ok) throw new Error('XML não encontrado');
                    return res.text();
                })
                .then(xml => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xml, "text/xml");
                    data.armor.sprites = Array.from(doc.getElementsByTagName('sprite')).map(s => ({
                        name: s.getAttribute('n'),
                        x: parseInt(s.getAttribute('x')),
                        y: parseInt(s.getAttribute('y')),
                        w: parseInt(s.getAttribute('w')),
                        h: parseInt(s.getAttribute('h')),
                        oX: parseInt(s.getAttribute('oX') || 0),
                        oY: parseInt(s.getAttribute('oY') || 0),
                        oW: parseInt(s.getAttribute('oW') || 0),
                        oH: parseInt(s.getAttribute('oH') || 0),
                        pX: parseFloat(s.getAttribute('pX') || 0.5),
                        pY: parseFloat(s.getAttribute('pY') || 0.5)
                    }));
                    updatePreview();
                })
                .catch(e => {
                    console.error('Erro ao carregar XML:', e);
                    delete data.armor;
                    updatePreview();
                });
        }

        function loadAsset(key, name, folder, isWeapon = false) {
            data[key] = {img: new Image(), sprites: []};
            data[key].img.src = basePath + `${folder}/Png/${name}.png`;
            data[key].img.onload = () => updatePreview();
            if (!isWeapon) {
                fetch(basePath + `${folder}/Xml/${name}.xml`)
                    .then(res => res.text())
                    .then(xml => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(xml, "text/xml");
                        data[key].sprites = Array.from(doc.getElementsByTagName('sprite')).map(s => ({
                            name: s.getAttribute('n'),
                            x: parseInt(s.getAttribute('x')),
                            y: parseInt(s.getAttribute('y')),
                            w: parseInt(s.getAttribute('w')),
                            h: parseInt(s.getAttribute('h')),
                            oX: parseInt(s.getAttribute('oX') || 0),
                            oY: parseInt(s.getAttribute('oY') || 0),
                            oW: parseInt(s.getAttribute('oW') || 0),
                            oH: parseInt(s.getAttribute('oH') || 0),
                            pX: parseFloat(s.getAttribute('pX') || 0.5),
                            pY: parseFloat(s.getAttribute('pY') || 0.5)
                        }));
                        updatePreview();
                    })
                    .catch(e => {
                        console.error('Erro XML:', e);
                        delete data[key];
                        updatePreview();
                    });
            }
        }

        function tintImage(img, color) {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            ctx.globalCompositeOperation = "multiply";
            ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = "destination-atop";
            ctx.drawImage(img, 0, 0);
            return canvas;
        }

        function calcularPosicao(pivotX, pivotY, sprite) {
            if (!sprite) return [0, 0];
            const posX = pivotX - (sprite.pX * sprite.oW - sprite.oX);
            const posY = pivotY - (sprite.pY * sprite.oH - sprite.oY);
            return [posX, posY];
        }

        function rotateImage(img, angle) {
            const rad = angle * Math.PI / 180;
            const sin = Math.abs(Math.sin(rad));
            const cos = Math.abs(Math.cos(rad));
            const canvas = document.createElement("canvas");
            canvas.width = Math.ceil(img.width * cos + img.height * sin);
            canvas.height = Math.ceil(img.width * sin + img.height * cos);
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = false;
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rad);
            ctx.drawImage(img, -img.width / 2, -img.height / 2);
            return canvas;
        }

        function montarFrame(frameIndex) {
            if (!data.body || !data.body.sprites || data.body.sprites.length === 0) return null;
            const bodySprite = data.body.sprites[frameIndex] || data.body.sprites[0];
            const pivotX = bodySprite.pX * bodySprite.oW;
            const pivotY = bodySprite.pY * bodySprite.oH;

            let bodyImg = data.body.img;
            if (bodyColor.r !== 255 || bodyColor.g !== 255 || bodyColor.b !== 255) {
                bodyImg = tintImage(bodyImg, bodyColor);
            }
            const bodyCrop = cropImage(bodyImg, bodySprite.x, bodySprite.y, bodySprite.w, bodySprite.h);
            const bodyPos = calcularPosicao(pivotX, pivotY, bodySprite);

            const crops = [{ img: bodyCrop, pos: bodyPos, key: 'body' }];

            ['armor', 'amuleto', 'pet', 'head'].forEach(key => {
                if (data[key] && data[key].sprites && data[key].sprites.length > 0) {
                    const s = data[key].sprites[Math.min(frameIndex, data[key].sprites.length - 1)];
                    const crop = cropImage(data[key].img, s.x, s.y, s.w, s.h);
                    const pos = calcularPosicao(pivotX, pivotY, s);
                    crops.push({ img: crop, pos, key });
                }
            });

            if (data.eye && data.eye.sprites && data.eye.sprites.length > 0) {
                const s = data.eye.sprites[Math.min(frameIndex, data.eye.sprites.length - 1)];
                let eyeCrop = cropImage(data.eye.img, s.x, s.y, s.w, s.h);
                if (eyeColor.r !== 255 || eyeColor.g !== 255 || eyeColor.b !== 255) {
                    eyeCrop = tintImage(eyeCrop, eyeColor);
                }
                const pos = calcularPosicao(pivotX, pivotY, s);
                crops.push({ img: eyeCrop, pos, key: 'eye' });
            }

            if (data.weapon && data.weapon.img) {
                const rotated = rotateImage(data.weapon.img, data.weapon.angle || 0);
                const pos = [
                    pivotX + (data.weapon.offset[0] || 0) - rotated.width / 2,
                    pivotY + (data.weapon.offset[1] || 0) - rotated.height / 2
                ];
                crops.push({ img: rotated, pos, key: 'weapon' });
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            crops.forEach(c => {
                minX = Math.min(minX, c.pos[0]);
                minY = Math.min(minY, c.pos[1]);
                maxX = Math.max(maxX, c.pos[0] + c.img.width);
                maxY = Math.max(maxY, c.pos[1] + c.img.height);
            });

            const canvas = document.createElement("canvas");
            canvas.width = Math.ceil(maxX - minX) || 1;
            canvas.height = Math.ceil(maxY - minY) || 1;
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = false;

            const order = ['weapon', 'body', 'armor', 'amuleto', 'pet', 'head'];
            order.forEach(k => {
                const c = crops.find(crop => crop.key === k);
                if (c) ctx.drawImage(c.img, c.pos[0] - minX, c.pos[1] - minY);
            });

            const eye = crops.find(c => c.key === 'eye');
            if (eye) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.drawImage(eye.img, eye.pos[0] - minX, eye.pos[1] - minY);
            }

            return canvas;
        }

        function cropImage(img, x, y, w, h) {
            const canvas = document.createElement("canvas");
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
            return canvas;
        }

        function updatePreview() {
            const canvas = montarFrame(0);
            if (canvas) {
                const prev = document.getElementById('preview');
                prev.width = canvas.width;
                prev.height = canvas.height;
                prev.getContext("2d").drawImage(canvas, 0, 0);
                document.getElementById('status').innerText = 'Preview atualizado!';
            } else {
                document.getElementById('status').innerText = 'Selecione um corpo primeiro.';
            }
        }

        async function generateAll() {
            if (!data.body || !data.body.sprites) {
                document.getElementById('status').innerText = 'Selecione um corpo primeiro.';
                return;
            }
            const zip = new JSZip();
            const total = data.body.sprites.length;
            document.getElementById('status').innerText = 'Gerando ZIP...';
            for (let i = 0; i < total; i++) {
                const canvas = montarFrame(i);
                const blob = await new Promise(r => canvas.toBlob(r));
                zip.file(`${data.body.sprites[i].name.replace(/[\\/]/g, '_')}.png`, blob);
            }
            const content = await zip.generateAsync({type: 'blob'});
            saveAs(content, 'Personagem_MagicRampage.zip');
            document.getElementById('status').innerText = 'ZIP gerado e baixado!';
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1,3),16);
            const g = parseInt(hex.slice(3,5),16);
            const b = parseInt(hex.slice(5,7),16);
            return {r, g, b};
        }

        async function loadCatalog() {
            await loadWeaponConfigs();
            try {
                const res = await fetch(basePath + 'catalog.json');
                if (!res.ok) throw new Error();
                catalog = await res.json();

                const armorList = [];
                catalog.armor.folders.forEach(folder => {
                    armorList.push({
                        name: folder.name,
                        type: 'folder',
                        display: folder.name,
                        with_helmet: folder.with_helmet,
                        without_helmet: folder.without_helmet
                    });
                });
                catalog.armor.single.forEach(name => {
                    armorList.push({
                        name: name,
                        type: 'single',
                        display: name.replace(/_/g, ' ')
                    });
                });
                armorList.sort((a,b) => a.display.localeCompare(b.display));

                createCatalog('bodyCatalog', catalog.body.map(n=>({name:n})), folders.body);
                createCatalog('armorCatalog', armorList, folders.armor);
                createCatalog('amuletoCatalog', catalog.amuleto.map(n=>({name:n})), folders.amuleto);
                createCatalog('petCatalog', catalog.pet.map(n=>({name:n})), folders.pet);
                createCatalog('headNormalCatalog', catalog.head.normal.map(n=>({name:n})), folders.head);
                const skinClassesList = catalog.head.skins.map(s => ({
                    class: s.class,
                    folder: s.folder,
                    preview_png: s.preview_png,
                    variations: s.variations,
                    display: s.class
                }));
                createCatalog('skinClassesCatalog', skinClassesList, folders.head, false, true);
                createCatalog('eyeCatalog', catalog.eye.map(n=>({name:n})), folders.eye);

                const weaponCategoriesList = catalog.weapon.categories.map(c => ({
                    category: c.category,
                    folder: c.folder,
                    preview_png: c.preview_png,
                    variations: c.variations,
                    display: c.category
                }));
                createCatalog('weaponCategoriesCatalog', weaponCategoriesList, folders.weapon, true, false, false, true);

                document.getElementById('status').innerText = 'Catálogo carregado! Selecione as imagens.';
            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = 'Erro ao carregar catalog.json';
            }
        }

        const accButtons = document.querySelectorAll(".accordion-button");
        accButtons.forEach(button => {
            button.addEventListener("click", function () {
                accButtons.forEach(other => {
                    if (other !== this) {
                        other.classList.remove("active");
                        other.nextElementSibling.style.maxHeight = null;
                    }
                });
                this.classList.toggle("active");
                const panel = this.nextElementSibling;
                if (panel.style.maxHeight) {
                    panel.style.maxHeight = null;
                } else {
                    panel.style.maxHeight = panel.scrollHeight + "px";
                }
            });
        });

        window.onload = loadCatalog;
    </script>
</body>
</html>
